---

const base = import.meta.env.BASE_URL === "/" ? "" : import.meta.env.BASE_URL;
---

<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href={ base + "/favicon.svg" } />
		<meta name="viewport" content="width=device-width" />
		<meta name="generator" content={Astro.generator} />
		<title>Typing Rust Patterns</title>
	</head>
	<body>
		<div id="grid">
			<div>
				<h1><span>T</span>yping <span>Ru</span>st <span>P</span>atterns</h1>
				<p>
					Welcome to the interactive pattern typer!<br/>
					Write `pattern: type` in the input box to see it get typechecked.<br/>
					Example: `&[ref x]: &[T]`
				</p>
			</div>
			<div id="options"/>
			<input type="text" id="input" spellcheck="false"/>
			<div id="terminal"/>
			<footer>
				<b><a href="https://github.com/Nadrieril/typing-rust-patterns" target="_blank">See on Github</a></b>.
				Frontend adapted from
				<a href="https://github.com/lyonsyonii/rubri" target="_blank">rubri</a>.
			</footer>
		</div>
	</body>
</html>

<style>
	body {
		height: 100vh;
		font-family: 'Courier New', Courier, monospace;
		margin: 0;
		padding: 0;
	}
	#grid {
		height: calc(100% - 1rem);
		margin-left: 1rem;
		margin-right: 1rem;
		display: grid;
		grid-template-rows: min-content min-content min-content 1fr 1rem;
		gap: .5rem;
	}
	#input {
		font-family: 'Courier New', Courier, monospace;
		font-size: medium;
		resize: none;
	}
	#terminal {
		white-space: pre-wrap;
	}
	footer {
		margin-top: auto;
	}
	span {
		text-decoration: underline;
	}
</style>

<script>
	import { Solver } from "../solver";
	import { setupEditor } from "../editor";
	import { AnsiUp } from "ansi_up";
	
	const input = document.body.querySelector<HTMLTextAreaElement>("#input")!;
	const options_container = document.getElementById("options")!;
	const termElement = document.getElementById("terminal")!;

	const ansiUp = new AnsiUp();
	input.value = '[&x]: &mut [&T]';
	termElement.innerHTML = "Loading...";

	setupEditor(input);

	// Solver initialization
	const solver = new Solver();

	solver.onLoaded((options) => {
		// Setup the options.
		for (const option of options) {
			const label = document.createElement("label");
			label.setAttribute("for", option.name);
			label.innerHTML = option.name;
			options_container.appendChild(label);

			if (option.values.length == 2 && option.values[0] == "true" && option.values[1] == "false") {
				const box = document.createElement("input");
				box.setAttribute("type", "checkbox");
				box.id = option.name;
				box.addEventListener("change", () => {
					solver.set_key(option.name, box.checked ? "true" : "false");
					runSolver()
				});
				options_container.appendChild(box);
			} else {
				const select = document.createElement("select");
				select.id = option.name;
				for (const value of option.values) {
					const opt = document.createElement("option");
					opt.setAttribute("value", value);
					opt.innerHTML = value;
					select.appendChild(opt);
				}
				select.addEventListener("change", () => {
					solver.set_key(option.name, select.value);
					runSolver()
				});
				options_container.appendChild(select);
			}

			options_container.appendChild(document.createElement("br"));
		}

		// Run the solver the first time.
		runSolver()
	});

	// When result is received from a running Solver write it to the terminal
	let lastInput = "";
	solver.onResult(result => {
		termElement.innerHTML = ansiUp.ansi_to_html(result.replaceAll("\n", "\r"));
		if (lastInput && lastInput !== input.value) {
			// Re-run if the input changed while the solver was running.
			input.dispatchEvent(new Event("input"));
		}
	});

	// Typecheck the input
	function runSolver() {
		if (solver.running) {
			return;
		}
		lastInput = input.value;
		solver.run_solver(input.value || "")
	}

	// Re-run the solver whenever the input changes.
	input.addEventListener("input", runSolver);
</script>
