---

const base = import.meta.env.BASE_URL === "/" ? "" : import.meta.env.BASE_URL;
---

<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href={ base + "/favicon.svg" } />
		<meta name="viewport" content="width=device-width" />
		<meta name="generator" content={Astro.generator} />
		<title>Rust Browser Interpreter</title>
	</head>
	<body>
		<div id="grid">
			<div>
				<h1><span>Ty</span>ping <span>Ru</span>st <span>P</span>atterns</h1>
				<b><a href="https://github.com/Nadrieril/typing-rust-patterns" target="_blank">See on Github</a></b>.
				Frontend shamelessly borrowed from
				<a href="https://github.com/lyonsyonii/rubri" target="_blank">rubri</a>.
			</div>
			<div id="live-edit-wrapper">
				<label for="print-last">Print last expression</label>
				<input id="print-last" type="checkbox" checked />
				<label for="inherited_ref_on_ref">Inherited ref on ref</label>
				<select id="inherited_ref_on_ref">
				  <option value="EatOuter">EatOuter</option>
				  <option value="EatInner">EatInner</option>
				  <option value="EatBoth">EatBoth</option>
				</select>
			</div>
			<textarea id="input" spellcheck="false" />
			<button>RUN</button>
			<div id="terminal" />
		</div>
	</body>
</html>

<style>
	body {
		height: 100vh;
		font-family: 'Courier New', Courier, monospace;
		margin: 0;
		padding: 0;
	}
	#grid {
		height: calc(100% - 1rem);
		margin-left: 1rem;
		margin-right: 1rem;
		display: grid;
		grid-template-rows: min-content min-content 1fr 5rem 1fr;
		gap: .5rem;
	}
	button {
		font-family: inherit;
		font-weight: 700;
		font-size: x-large;
	}
	textarea#input {
		font-size: x-large;
		resize: none;
	}
	#terminal {
		white-space: pre-wrap;
	}
	#live-edit, #live-edit-wrapper {
		user-select: none;
	}
	span {
		text-decoration: underline;
	}
</style>

<script>
	import { Interpreter } from "../interpreter";
	import { setupEditor } from "../editor";
	import { AnsiUp } from "ansi_up";
	
	const input = document.body.querySelector<HTMLTextAreaElement>("textarea#input")!;
	const runButton = document.body.querySelector<HTMLButtonElement>("button")!;
	const printLast = document.body.querySelector<HTMLInputElement>("#print-last")!;
	const inherited_ref_on_ref = document.body.querySelector<HTMLInputElement>("#inherited_ref_on_ref")!;
	const termElement = document.getElementById("terminal")!;

	const ansiUp = new AnsiUp();
	input.value = "Downloading...";
	input.placeholder = "Write your code...";
	input.readOnly = true;

	// Interpreter initialization
	let lastInput = "";
	const interpreter = new Interpreter();

	// When Interpreter has finished loading, add default code
	interpreter.onLoaded(() => {
		input.readOnly = false;
		input.value = '[&x]: &[&T]';
		runButton.click();
		// interpreter.run(input.value);
	});

	// When Interpreter is running disable the "Run" button
	interpreter.onRun(() => {
		runButton.disabled = true;
		termElement.innerHTML = "Running...";
	});

	// When result is received from a running Interpreter write it to the terminal
	interpreter.onResult(result => {
		termElement.innerHTML = ansiUp.ansi_to_html(result.replaceAll("\n", "\r"));
		runButton.disabled = false;
		if (lastInput && lastInput !== input.value) {
			input.dispatchEvent(new Event("input"));
		}
	});
	
	setupEditor(input, runButton);

	function runInterpreter() {
		if (runButton.disabled) {
			return;
		}
		lastInput = input.value;
		interpreter.run(input.value || "", printLast.checked, inherited_ref_on_ref.value)
	}

	input.addEventListener("input", runInterpreter);
	runButton.addEventListener("click", runInterpreter);
	inherited_ref_on_ref.addEventListener("change", runInterpreter);
</script>
